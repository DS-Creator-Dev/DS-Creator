Proposed generic-purpose bank allocation model:

MAIN
  A + B =  BG_VRAM       256KB            0x06000000 - 0x0603FFFF
  E     = OBJ_VRAM        64KB            0x06400000 - 0x0640FFFF
  F     =  BG_EXT_PAL     16KB (2 slots)  0x06894000 - 0x06897FFF----|
  G     = OBJ_EXT_PAL      8KB (1 slot)   0x06890000 - 0x06891FFF    |
                                                                     |
SUB                                                                  |
  C     =  BG_VRAM       128KB            0x06200000 - 0x0621FFFF    |
  D     = OBJ_VRAM       128KB            0x06600000 - 0x0661FFFF    |   Continuous?
  H     =  BG_EXT_PAL     32KB (4slots)   0x06898000 - 0x0689FFFF----|-- 0x06894000
  I     = OBJ_VRAM         8KB (1slots)   0x068A0000 - 0x068A3FFF----|   0x068A3FFF


Main Engine - VRAM allocations (worst-case scenario)

The 256KB of BG_VRAM is split into 16 portions of 16KB (let's call them ZONEs). The first 64KB can contain
tilemap bases. 

  BG0, BG1 = Text8bpp 512x512
  
	This is the maximum possible for all video modes. Each such map is 8KB in size,
	so ZONE 0 can contain them.
	
  BG2, BG3 = Bitmap16bpp
	A single 256x512@16bpp bitmap can fit in the whole 256KB of BG VRAM, ONLY if this is 
	the single thing that resides there. 
	
	A single 128x128@16bpp bitmap occupies 2 ZONEs (32KB).
	A single 256x256@16bpp bitmap occupies 8 ZONEs (128KB).
	
	If we would try to fill the VRAM as much as we can, we can do the following:	
	- 1 bitmap   256x512@16bpp => 16 ZONEs
	
	- 2 bitmaps  256x256@16bpp => 16 ZONEs
	
	- 1 bitmap   256x256@16bpp
	  1 bitmap   128x126@16bpp => 11 ZONEs, leaving 5 ZONEs (80KB) for tiles (1280 tiles@8bpp)
	  2 tilemaps 512x512@ 8bpp
	  
	  
In practice, the numbers can be much lower. Tile streaming can make all tile maps 256x256. Assume 8bpp bitmaps
are suitable for most of the cases, and they are half in size compared to the 16bpp ones. 


IT'S BETTER NOT TO MIX MAPS WITH TILESETS!

As the hardware forces us to put screen bases at the beginning of VRAM, we should stick to that and put all the
map data there. After that follow tiles and it's actually plenty of space for them. Not to mention that all the
maps sizes are known beforehand through bgInit()s, so the tiles should be placed staring with the first ZONE we
haven't put any maps in.

							|--------------------------------------| 0x06000000
							|              Maps + Bitmaps          |
							|--------------------------------------| 0x060XXXXX
							|                                      |
							|               Tiles...               |
							|                                      |
							|--------------------------------------|

Preferably, each map should use its own ZONEs for tiles, unless there are maps that share common tilesets.
One ZONE can hold 256@8bpp tiles, respectively 512@4bpp tiles.


About loading tiles in VRAM

We aim for automatic tiles loading. We tell the engine "ok I want tileset X to be used with map I" and it should be able
to place the data at an accessible offset, load the palette and do the necessary modifications on the bytes dynamically 
(e.g. change palette bank, adjust the starting tile number).

	Data predeclaring - Possible solution
	
		On scene initialization, we are specifying the resources we want to use. Then, the engine analyzes them and computes
		the spaces desired for each map, detects possible overflows and finally loads the data. Under normal circumstances,
		the loaded resources should not change their places during the scene's execution, therefore there is no need for the
		VRAM allocators. They can, however, be assigned to the free space left in VRAM for whatever special operations (e.g.
		temporary tiles/sprites).
	
	Automatic palette registration
	
		There are two cases:
		- 4-bit palette, there are 16 slots of  15 entries (excluding transparent color indices), all in BG_PALETTE
		- 8-bit palette, there are 16 slots of 256 entries (including extended palettes) - for OBJ
						 there is   1 slot  of 256 entries                               - for BG*  !!!
		
		* Extended Palettes work ONLY on BG0, BG1. Each background can choose exactly one extra palette slot from BGX_CNT.
			BG0 - slots 0,2
			BG1 - slots 1,3		
		  This proposed model uses extended palette slots 2,3 because they don't overlap with the extended OBJ palettes.
		  That means for BG0_CNT, BG1_CNT, bit13 is set to 1.
		
		Possible algorithm:
		  - to load a 4bit palette, just reserve a palette bank 0..15 for it. 
		    ? possible discussion when we have plenty of small palettes that can be fit into a single palette bank
		  - to load an 8bit palette:
			- find a palette slots that can fit it (has more empty entries than we need to load it). 
			- copy it
			? to avoid duplicate colors, for each entry remember how many assets use it. If it is no longer used, it can
			  be safely deallocated. Analogy with "shared pointer".
		
		After palette allocation, a dictionary i_res->i_mem can be returned, meaning that: "The color with index i_res in the
		loaded binary data has the dynamically assigned index i_mem". Note that i_mem can encode information about the
		palette used besides just the color index.
		
	Loading an asset
		By asset, we mean visual data (tiles/bitmap) + palette. We know apriori if it is 4bit/8bit.
		- load its palette. Obtain the i_res->i_mem mapping.
		- find a suitable offset for the data. 
		- when copying the data, replace each reference to the palette index with the correct index obtained via the map
		  mentioned above.
		- it would be nice to return the start offset of the tiles data to be used when loading the maps.
		
	Loading a map
		Due to the model described above, tile maps should be encoded in a way that tells for each tile the tileset it belongs to.
		This way, we have a straight forward way to decode them:
		
		- read tile data <TilesetId, TileNumber>
		- retrieve TilesetId relative offset O
		- place tile (O/TileSize + TileNumber) on the map and process next tile
		
Sprites	

	Loading sprites should be easier than loading maps, due to the relative lack of constraints.
	Possible scenarios:
	  1. load the entire sprite sheet and switch the frame index in OAM to create animations
	  2. reserve a single entry having the sprite's size and dynamically rewrite animation frames there
	  
	  Option 1 is good for large sprites that are expensive to load each frame, but makes ineffective use of memory.
	  This may also help when we have a lot of independent sprites accessing the same memory (e.g. 10 enemies with the
	  exact same frames).
	  Option 2 is good when we have small sprites that can be updated easily. It works when plenty of different entities
	  with unique graphics are encountered during the gameplay, so that they can't be preloaded in VRAM in their entirety.
	
	THE BIG ISSUE WITH SPRITES - adjust their Z-indices. The problem reduces to OAM-swapping but it merely depends on the context.
	
I DON'T KNOW IF THIS STRATEGY WORKS, WE'LL FIGURE OUT ON THE GO

This model does not take into account some edge-cases, like the 1024x1024 bitmap or the rotation/scaling maps. 
It would be a great deal if we do everything according to the current plan, so the rest are just bonus features.